""" This module contains the Model class for the GPT model."""

from dataclasses import dataclass
import logging as log
from typing import List, Dict, Any
import re
import asyncio
import aiohttp


@dataclass
class Model:
    """
    Configuration class for the GPT model.

    Attributes:
        gpt_api_key (str): The API key for the GPT model.
        gpt_base_url (str): The base URL for the GPT model.
        model (str): The name of the GPT model.
        models (List[Dict[str, Any]]): A list of available GPT models.
    """

    api_key: str
    url: str
    model_name: str
    model: Dict[str, Any]
    models: List[Dict[str, Any]]

    def __init__(self, key: str, url: str, model_name: str, use_model: bool = True):
        self.api_key = key
        self.url = url
        self.model_name = model_name
        self.use_model = use_model
        self.models = [
            {"Name": "gpt-3.5-turbo", "Tokens": 4096},
            {"Name": "gpt-3.5-turbo-16k", "Tokens": 16385},
            {"Name": "gpt-4", "Tokens": 8192},
            {"Name": "gpt-4-32k", "Tokens": 32768},
            {"Name": "gpt-4o", "Tokens": 128000},
        ]
        self.model = next((m for m in self.models if m["Name"] == self.model_name))
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}",
        }

    async def summarise(self, prompt: str, session: aiohttp.ClientSession) -> str:
        """
        Sends a prompt to GPT and returns the response.

        Parameters:
            prompt (str): The input prompt for GPT.
            session (aiohttp.ClientSession): The aiohttp client session.

        Returns:
            str: The response generated by GPT.
        """
        token_count = self.count_tokens(prompt)
        if self.model and token_count > self.model["Tokens"]:
            log.warning(
                "The prompt contains too many tokens for the selected model %s/%s. Please reduce the size of the prompt.",
                token_count,
                self.model["Tokens"],
            )
            return ""

        payload = {
            "model": self.model_name,
            "messages": [{"role": "user", "content": prompt}],
        }
        uri = f"{self.url}/chat/completions"
        headers = self.headers

        return await self._retry_request(uri, payload, headers, session)

    async def _retry_request(
        self, uri: str, payload: dict, headers: dict, session: aiohttp.ClientSession
    ) -> str:
        max_retries = 3
        retry_delay = 2  # seconds
        retry_message = ("Retrying in %s seconds...", retry_delay)

        for attempt in range(max_retries):
            try:
                async with session.post(
                    uri, json=payload, headers=headers, timeout=10
                ) as response:
                    if response.status in {401, 403, 404} or response.status >= 500:
                        return self._handle_http_error(
                            response, attempt, max_retries, retry_delay
                        )
                    return await self._handle_response(response)
            except aiohttp.ClientError as e:
                if attempt < max_retries - 1:
                    log.info(retry_message)
                    await asyncio.sleep(retry_delay)
                    continue
                log.error("Client Error: %s", str(e))
                return f"Error: Client error occurred: {str(e)}"
            except asyncio.TimeoutError:
                if attempt < max_retries - 1:
                    log.info(retry_message)
                    await asyncio.sleep(retry_delay)
                    continue
                log.error("Request Timeout: The request timed out.")
                return "Error: Request timed out. Please try again later."

        return "Error: Failed to get a successful response after retries."

    def _handle_http_error(
        self,
        response: aiohttp.ClientResponse,
        attempt: int,
        max_retries: int,
        retry_delay: int,
    ) -> str:
        if response.status == 401:
            log.error("Unauthorized: Check your API key and permissions.")
            return "Error: Unauthorized. Check your API key and permissions."
        if response.status == 403:
            log.error("Forbidden: You do not have access to this resource.")
            return "Error: Forbidden. You do not have access to this resource."
        if response.status == 404:
            log.error("Not Found: The requested resource could not be found.")
            return "Error: Not Found. The requested resource could not be found."
        if response.status >= 500:
            log.error("Server Error: The server encountered an error.")
            if attempt < max_retries - 1:
                log.info("Retrying in %s seconds...", retry_delay)
                return ""
            return "Error: Server encountered an error. Please try again later."
        return "Error: Unknown error occurred."

    async def _handle_response(self, response: aiohttp.ClientResponse) -> str:
        result = await response.json()
        if response.status != 200:
            log.error(result.get("error", {}).get("message", "Unknown error"))
            return f"Error: {result.get('error', {}).get('message', 'Unknown error')}"
        return str(result["choices"][0]["message"]["content"])

    def count_tokens(self, text: str) -> int:
        """
        Calculates the token count for a given text.

        Parameters:
        text (str): The input text for which the token count needs to be calculateDevOpsConfig.

        Returns:
        int: The total count of tokens in the given text.
        """
        word_count = len(re.findall(r"\b\w+\b", text))
        char_count = len(re.sub(r"\s", "", text))
        return word_count + char_count
